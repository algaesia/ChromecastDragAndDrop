<html>
	<head>
		<title> TESTING WEBGL </title>
		<script type="text/javascript" src="jquery-2.1.1.min.js"></script>
		<script type="text/javascript" src="jquery-ui.min.js"></script>
		<script type="text/javascript" src="gl-Matrix-min.js"></script>
		<script>
			//represents model view matrix
			var mvMatrix = mat4.create();
			
			//perspective matrix
			var pMatrix = mat4.create();
			
			//shader program, to which
			//vert and frag shaders
			//are linked to
			var shaderProgram;
			
			//webGL context, used to
			//draw everything
			var gl;
			
			var canvas;
			
			//triangles that appear on
			//screen, first is GL buffer
			//second is an array of verts
			var square1VertexBuffer;
			var square1;
			
			var square1ColourBuffer;
			var square1Colours;
			
			var square1CentrePos = [ -2.0, 1.0, -7.0 ];
			var square1StartPos = [ square1CentrePos[0], square1CentrePos[1], square1CentrePos[2] ];
			var square1RotX = 0;
			var square1RotY = 0;
			var square1RotZ = 0;
			
			var fps = 60;
			var timer = 0;
			
			//Sets everything up
			function webGLStart()
			{
				//get canvas element
				canvas = document.getElementById("gameCanvas");

				initGL(canvas);
				initShaders();
				initBuffers();
				
				gl.clearColor(0.1,0.5,0.2,1.0);
				gl.enable(gl.DEPTH_TEST);
				
				gameLoop();
			}
			
			function gameLoop()
			{
				timer++;
				
				updateScene();
				drawScene();
				
				//browser optimised, only runs when visible AND runs at specified frame rate
				setTimeout(function() { requestAnimationFrame(gameLoop); }, 1000 / fps);
			}
			
			//initialises buffers required
			//and passes the data to gfx
			//card ready to be rendered
			function initBuffers()
			{				
				//****************************************************
				//create new buffer
				square1VertexBuffer = gl.createBuffer();
				
				//bind it
				gl.bindBuffer(gl.ARRAY_BUFFER, square1VertexBuffer);
				
				//points on screen
				square1 = [ 1.0, 1.0, 0,
							  -1.0, 1.0, 0,
							  1.0, -1.0, 0,
							  -1.0, -1.0, 0 ];
							  
				//create a buffer on the gfx card based on the array passed in
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(square1), gl.STATIC_DRAW);
				
				square1VertexBuffer.itemSize = 3;
				square1VertexBuffer.numItems = 4;
				
				square1ColourBuffer = gl.createBuffer();
				
				gl.bindBuffer(gl.ARRAY_BUFFER, square1ColourBuffer);
				
				//one vec4 per vertex
				square1Colours = [
					0.5, 0.0, 0.5, 1.0,
					0.0, 1.0, 0.0, 1.0,
					0.0, 0.5, 1.0, 1.0,
					1.0, 0.0, 0.5, 1.0
				];
				
				//create memory for array
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(square1Colours), gl.STATIC_DRAW);
				
				//(r, g, b, a) * 3
				square1ColourBuffer.itemSize = 4;
				square1ColourBuffer.numItems = 4;
				//****************************************************
			}
			
			function updateScene()
			{
				square1CentrePos[0] += 0.02;
				
				square1RotX += 0.01;
				square1RotY += -0.05;
				//square1RotZ += -0.1;
				
				if (square1CentrePos[0] > 6)
				{
					square1CentrePos[0] = square1StartPos[0];
				}

				//represents the model
				//set mvMatrix to be identity
				mat4.identity(mvMatrix);
				
				//matrix at the centre of the world
				mat4.translate(mvMatrix, mvMatrix, square1CentrePos);
				
				mat4.rotateX(mvMatrix, mvMatrix, square1RotX);
				mat4.rotateY(mvMatrix, mvMatrix, square1RotY);
				//mat4.rotateZ(mvMatrix, mvMatrix, square1RotZ);			
				
				mat4.scale(mvMatrix, mvMatrix, vec3.fromValues(Math.sin(timer * .05), Math.cos(timer * .05), 5));
				
				gl.uniform1f(shaderProgram.totalTimer, timer);
			}
			
			//sets up things to be ready for drawing
			function drawScene()
			{
				//clear screen
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				
				//get position of global variable on gfx card at position pMatrixUniform, saving it into pMatrix
				gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
				
				//get position of global variable on gfx card at position mvMatrixUniform, saving it into mvMatrix
				gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
				
				//****************************************************************************************************************
				//****************************************************************************************************************
				//bind buffer holding vertex information
				gl.bindBuffer(gl.ARRAY_BUFFER, square1VertexBuffer);
				
				//tell openGL what kind of info is in this buffer
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, square1VertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
				
				//bind buffer holding colour information
				gl.bindBuffer(gl.ARRAY_BUFFER, square1ColourBuffer);
				gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, square1ColourBuffer.itemSize, gl.FLOAT, false, 0, 0);
				
				//draw triangles, using an array, from index 0 to 3
				gl.drawArrays(gl.TRIANGLE_STRIP, 0, square1VertexBuffer.numItems);
				//****************************************************************************************************************
				//****************************************************************************************************************
			}
			
			function initShaders()
			{
				//get the source for the shaders, labeled
				//with IDs in the DOM
				var fragmentShader = getShader(gl, "shader-fs");
				var vertexShader = getShader(gl, "shader-vs");
				
				//create a program to which the
				//compiled shaders are attached
				shaderProgram = gl.createProgram();
				
				//attach compiled shaders
				gl.attachShader(shaderProgram, vertexShader);
				gl.attachShader(shaderProgram, fragmentShader);
				
				//link the program together
				gl.linkProgram(shaderProgram);
				
				if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))
				{
					alert("could not initialise shaders");
				}
				
				//use the program
				gl.useProgram(shaderProgram);
				
				//create variable in shaderProgram to track attribute location for shaderProgram's vertex position attribute
				shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aPosition");
				
				//enable attrib array in context, passing in the location of the vertex position
				//attribute variable in shaderProgram
				gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
				
				//create variable to store location of attribute for vertex colours
				shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aColour");
				
				//enable attrib array in context, passing in location of vertex position
				//attribute variable in shaderProgram
				gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);
				
				//create variables to track the uniform location of variables in the shader
				shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
				shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
				shaderProgram.totalTimer = gl.getUniformLocation(shaderProgram, "totalTimer");
				
				//set up perspective matrix, FOV = 45 deg, near plane = 0.1, far plane = 100
				//perspective mat is stored in pMatrix
				mat4.perspective(pMatrix, 45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
				
				//set up viewport
				gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);	
			}

			function initGL(a_Canvas)
			{
				try
				{
					//get the context of the canvas
					//setting it to be webGL
					gl = a_Canvas.getContext("experimental-webgl");
					
					//viewport is based on the size of the canvas
					gl.viewportWidth = a_Canvas.width;
					gl.viewportHeight = a_Canvas.height;
				}
				catch (e) 
				{
					alert("something went wrong");
				}
				
				if (!gl)
				{
					alert("could not initialise webgl");
				}
			}
			
			function getShader(a_GL, a_ID)
			{
				var shaderScript = document.getElementById(a_ID);
				if (!shaderScript)
				{
					return null;
				}
				
				var str = "";
				var k = shaderScript.firstChild;
				while (k)
				{
					if (k.nodeType == 3)
					{
						str += k.textContent;
					}
					k = k.nextSibling;
				}
				
				var shader;
				if (shaderScript.type == "x-shader/x-fragment")
				{
					shader = a_GL.createShader(a_GL.FRAGMENT_SHADER);
				}
				else if (shaderScript.type == "x-shader/x-vertex")
				{
					shader = a_GL.createShader(a_GL.VERTEX_SHADER);
				}
				else
				{
					return null;
				}
				
				a_GL.shaderSource(shader, str);
				a_GL.compileShader(shader);
				
				if (!a_GL.getShaderParameter(shader, a_GL.COMPILE_STATUS))
				{
					alert(a_GL.getShaderInfoLog(shader));
					return null;
				}
				
				return shader;
			}
		</script>
		<style>
			#dragResize
			{
				width:480;
				height:480;
				padding:0.5;
				border:solid 2px;
				position:absolute;
			}
			#resizable
			{
				width:480;
				height:480;
				border:solid 2px;
			}
			#accordion
			{
				border:solid 6px;
			}		
			#progressBarDraggable
			{
				width:100;
				height:25;
				border:solid 2px;
				background:yellow;
			}
			#sliderBar
			{
				width:100;
				height:25;
				border:solid 2px;
				background:yellow;
			}
		</style>
		<script>
			$(function() {
				$("#dragResize").draggable().resizable;
			});

			$(function() {
				$("#resizable").resizable();
			});

			$(function() {
			    $( "#accordion" ).accordion();
			});

			$(function() {
			    $( "#progressBarDraggable" ).progressbar({value:5000}).draggable();
			});

			$(function() {
			    $( "#sliderBar" ).slider();
			});
		</script>
	</head>
	<body onload="webGLStart();">
		<div id="dragResize">
			This is draggable and resizable
		</div>
		<div id="progressBarDraggable">
			Progress bar
		</div>
		<div id="sliderBar">
			Slider
		</div>
		<div id="accordion">
			This is an accordion list
			<h2>SECTION 1</h2>
			<div>
				<p>
					Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.
				</p>
			</div>
			<h3>
				SECTION 2
			</h3>
			<div>
				<p>
					Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.
				</p>
			</div>
			<h4> SECTION 3 </h4>
			<div>
				<p>
					Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.
				</p>
			</div>
		</div>
		<canvas id="gameCanvas" style="border:none;" width="1280" height="720"></canvas>
		<script id="shader-fs" type="x-shader/x-fragment">
			precision mediump float;
			
			varying vec4 vColour;
			uniform float totalTimer;
			
			void main(void)
			{
				gl_FragColor = vec4(vColour.x, cos((1.0 - tan(vColour.y)) * totalTimer), tan(vColour.z * totalTimer), (vColour.w * 3.14159) / (vColour.x + 0.01));
			}
		</script>
		
		<script id="shader-vs" type="x-shader/x-vertex">
			attribute vec3 aPosition;
			attribute vec4 aColour;
			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			
			varying vec4 vColour;
			
			void main(void)
			{
				gl_Position = uPMatrix * uMVMatrix * vec4(aPosition, 1.0);
				vColour = aColour;
			}
		</script>
	</body>
</html>